// Tencent is pleased to support the open source community by making
// 蓝鲸智云 - 监控平台 (BlueKing - Monitor) available.
// Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.
// Licensed under the MIT License (the "License"); you may not use this file except in compliance with the License.
// You may obtain a copy of the License at http://opensource.org/licenses/MIT
// Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
// an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package etl_test

import (
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/TencentBlueKing/bkmonitor-datalink/pkg/transfer/etl"
)

// TestTransformMultiplyByFloat32 :
func TestTransformMultiplyByFloat32(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformMultiplyByFloat32(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformDivideByFloat32 :
func TestTransformDivideByFloat32(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformDivideByFloat32(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformAddByFloat32 :
func TestTransformAddByFloat32(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformAddByFloat32(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformSubtractByFloat32 :
func TestTransformSubtractByFloat32(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformSubtractByFloat32(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformMultiplyByFloat64 :
func TestTransformMultiplyByFloat64(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformMultiplyByFloat64(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformDivideByFloat64 :
func TestTransformDivideByFloat64(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformDivideByFloat64(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformAddByFloat64 :
func TestTransformAddByFloat64(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformAddByFloat64(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformSubtractByFloat64 :
func TestTransformSubtractByFloat64(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformSubtractByFloat64(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformMultiplyByInt :
func TestTransformMultiplyByInt(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformMultiplyByInt(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformDivideByInt :
func TestTransformDivideByInt(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformDivideByInt(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformAddByInt :
func TestTransformAddByInt(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformAddByInt(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformSubtractByInt :
func TestTransformSubtractByInt(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformSubtractByInt(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformMultiplyByInt8 :
func TestTransformMultiplyByInt8(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformMultiplyByInt8(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformDivideByInt8 :
func TestTransformDivideByInt8(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformDivideByInt8(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformAddByInt8 :
func TestTransformAddByInt8(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformAddByInt8(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformSubtractByInt8 :
func TestTransformSubtractByInt8(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformSubtractByInt8(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformMultiplyByInt16 :
func TestTransformMultiplyByInt16(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformMultiplyByInt16(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformDivideByInt16 :
func TestTransformDivideByInt16(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformDivideByInt16(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformAddByInt16 :
func TestTransformAddByInt16(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformAddByInt16(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformSubtractByInt16 :
func TestTransformSubtractByInt16(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformSubtractByInt16(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformMultiplyByInt32 :
func TestTransformMultiplyByInt32(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformMultiplyByInt32(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformDivideByInt32 :
func TestTransformDivideByInt32(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformDivideByInt32(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformAddByInt32 :
func TestTransformAddByInt32(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformAddByInt32(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformSubtractByInt32 :
func TestTransformSubtractByInt32(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformSubtractByInt32(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformMultiplyByInt64 :
func TestTransformMultiplyByInt64(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformMultiplyByInt64(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformDivideByInt64 :
func TestTransformDivideByInt64(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformDivideByInt64(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformAddByInt64 :
func TestTransformAddByInt64(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformAddByInt64(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformSubtractByInt64 :
func TestTransformSubtractByInt64(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformSubtractByInt64(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformMultiplyByUint :
func TestTransformMultiplyByUint(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformMultiplyByUint(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformDivideByUint :
func TestTransformDivideByUint(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformDivideByUint(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformAddByUint :
func TestTransformAddByUint(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformAddByUint(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformSubtractByUint :
func TestTransformSubtractByUint(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformSubtractByUint(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformMultiplyByUint8 :
func TestTransformMultiplyByUint8(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformMultiplyByUint8(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformDivideByUint8 :
func TestTransformDivideByUint8(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformDivideByUint8(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformAddByUint8 :
func TestTransformAddByUint8(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformAddByUint8(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformSubtractByUint8 :
func TestTransformSubtractByUint8(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformSubtractByUint8(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformMultiplyByUint16 :
func TestTransformMultiplyByUint16(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformMultiplyByUint16(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformDivideByUint16 :
func TestTransformDivideByUint16(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformDivideByUint16(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformAddByUint16 :
func TestTransformAddByUint16(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformAddByUint16(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformSubtractByUint16 :
func TestTransformSubtractByUint16(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformSubtractByUint16(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformMultiplyByUint32 :
func TestTransformMultiplyByUint32(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformMultiplyByUint32(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformDivideByUint32 :
func TestTransformDivideByUint32(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformDivideByUint32(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformAddByUint32 :
func TestTransformAddByUint32(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformAddByUint32(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformSubtractByUint32 :
func TestTransformSubtractByUint32(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformSubtractByUint32(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformMultiplyByUint64 :
func TestTransformMultiplyByUint64(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformMultiplyByUint64(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformDivideByUint64 :
func TestTransformDivideByUint64(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformDivideByUint64(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformAddByUint64 :
func TestTransformAddByUint64(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformAddByUint64(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}

// TestTransformSubtractByUint64 :
func TestTransformSubtractByUint64(t *testing.T) {
	cases := []struct {
		left, right interface{}
	}{
		{1, 2},
		{3, 3},
		{5, 4},
	}
	for _, c := range cases {
		fn := etl.TransformSubtractByUint64(c.right)
		result, err := fn(c.left)
		assert.NoError(t, err)
		assert.NotNil(t, result)
	}
}
