// Tencent is pleased to support the open source community by making
// 蓝鲸智云 - 监控平台 (BlueKing - Monitor) available.
// Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.
// Licensed under the MIT License (the "License"); you may not use this file except in compliance with the License.
// You may obtain a copy of the License at http://opensource.org/licenses/MIT
// Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
// an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package etl_test

import (
	"testing"
	"time"

	"github.com/stretchr/testify/assert"

	"github.com/TencentBlueKing/bkmonitor-datalink/pkg/transfer/etl"
)

// TestConvertBool : test convert bool
func TestConvertBool(t *testing.T) {
	var input bool
	cases := []struct {
		value, result interface{}
	}{
		{input, input},
		{nil, input},
	}
	for _, c := range cases {
		result, err := etl.TransformBool(c.value)
		assert.NoError(t, err)
		assert.Equal(t, c.result, result)
	}
}

// TestConvertNilBool : test convert bool allow nil
func TestConvertNilBool(t *testing.T) {
	var input bool
	cases := []struct {
		value, result interface{}
	}{
		{input, input},
		{nil, nil},
	}
	for _, c := range cases {
		result, err := etl.TransformNilBool(c.value)
		assert.NoError(t, err)
		assert.Equal(t, c.result, result)
	}
}

// TestConvertNotNilBool : test convert bool not allow nil
func TestConvertNotNilBool(t *testing.T) {
	var input bool
	cases := []struct {
		value, result interface{}
		err           error
	}{
		{input, input, nil},
		{nil, nil, etl.ErrTypeNotSupported},
	}
	for _, c := range cases {
		result, err := etl.TransformNotNilBool(c.value)
		assert.Equal(t, c.result, result)
		assert.Equal(t, c.err, err)
	}
}

// TestConvertAutoBool : test convert bool
func TestConvertAutoBool(t *testing.T) {
	var input bool
	cases := []struct {
		value, result interface{}
		pass          bool
	}{
		{input, input, true},
	}
	for _, c := range cases {
		result, err := etl.TransformAutoBool(c.value)
		if c.pass {
			assert.Equal(t, c.result, result)
		} else {
			assert.Error(t, err)
		}
	}
}

// TestConvertDuration : test convert duration
func TestConvertDuration(t *testing.T) {
	var input time.Duration
	cases := []struct {
		value, result interface{}
	}{
		{input, input},
		{nil, input},
	}
	for _, c := range cases {
		result, err := etl.TransformDuration(c.value)
		assert.NoError(t, err)
		assert.Equal(t, c.result, result)
	}
}

// TestConvertNilDuration : test convert duration allow nil
func TestConvertNilDuration(t *testing.T) {
	var input time.Duration
	cases := []struct {
		value, result interface{}
	}{
		{input, input},
		{nil, nil},
	}
	for _, c := range cases {
		result, err := etl.TransformNilDuration(c.value)
		assert.NoError(t, err)
		assert.Equal(t, c.result, result)
	}
}

// TestConvertNotNilDuration : test convert duration not allow nil
func TestConvertNotNilDuration(t *testing.T) {
	var input time.Duration
	cases := []struct {
		value, result interface{}
		err           error
	}{
		{input, input, nil},
		{nil, nil, etl.ErrTypeNotSupported},
	}
	for _, c := range cases {
		result, err := etl.TransformNotNilDuration(c.value)
		assert.Equal(t, c.result, result)
		assert.Equal(t, c.err, err)
	}
}

// TestConvertAutoDuration : test convert duration
func TestConvertAutoDuration(t *testing.T) {
	var input time.Duration
	cases := []struct {
		value, result interface{}
		pass          bool
	}{
		{input, input, true},
	}
	for _, c := range cases {
		result, err := etl.TransformAutoDuration(c.value)
		if c.pass {
			assert.Equal(t, c.result, result)
		} else {
			assert.Error(t, err)
		}
	}
}

// TestConvertString : test convert string
func TestConvertString(t *testing.T) {
	var input string
	cases := []struct {
		value, result interface{}
	}{
		{input, input},
		{nil, input},
	}
	for _, c := range cases {
		result, err := etl.TransformString(c.value)
		assert.NoError(t, err)
		assert.Equal(t, c.result, result)
	}
}

// TestConvertNilString : test convert string allow nil
func TestConvertNilString(t *testing.T) {
	var input string
	cases := []struct {
		value, result interface{}
	}{
		{input, input},
		{nil, nil},
	}
	for _, c := range cases {
		result, err := etl.TransformNilString(c.value)
		assert.NoError(t, err)
		assert.Equal(t, c.result, result)
	}
}

// TestConvertNotNilString : test convert string not allow nil
func TestConvertNotNilString(t *testing.T) {
	var input string
	cases := []struct {
		value, result interface{}
		err           error
	}{
		{input, input, nil},
		{nil, nil, etl.ErrTypeNotSupported},
	}
	for _, c := range cases {
		result, err := etl.TransformNotNilString(c.value)
		assert.Equal(t, c.result, result)
		assert.Equal(t, c.err, err)
	}
}

// TestConvertAutoString : test convert string
func TestConvertAutoString(t *testing.T) {
	var input string
	cases := []struct {
		value, result interface{}
		pass          bool
	}{
		{input, input, true},
	}
	for _, c := range cases {
		result, err := etl.TransformAutoString(c.value)
		if c.pass {
			assert.Equal(t, c.result, result)
		} else {
			assert.Error(t, err)
		}
	}
}

// TestConvertTime : test convert time
func TestConvertTime(t *testing.T) {
	var input time.Time
	cases := []struct {
		value, result interface{}
	}{
		{input, input},
		{nil, input},
	}
	for _, c := range cases {
		result, err := etl.TransformTime(c.value)
		assert.NoError(t, err)
		assert.Equal(t, c.result, result)
	}
}

// TestConvertNilTime : test convert time allow nil
func TestConvertNilTime(t *testing.T) {
	var input time.Time
	cases := []struct {
		value, result interface{}
	}{
		{input, input},
		{nil, nil},
	}
	for _, c := range cases {
		result, err := etl.TransformNilTime(c.value)
		assert.NoError(t, err)
		assert.Equal(t, c.result, result)
	}
}

// TestConvertNotNilTime : test convert time not allow nil
func TestConvertNotNilTime(t *testing.T) {
	var input time.Time
	cases := []struct {
		value, result interface{}
		err           error
	}{
		{input, input, nil},
		{nil, nil, etl.ErrTypeNotSupported},
	}
	for _, c := range cases {
		result, err := etl.TransformNotNilTime(c.value)
		assert.Equal(t, c.result, result)
		assert.Equal(t, c.err, err)
	}
}

// TestConvertAutoTime : test convert time
func TestConvertAutoTime(t *testing.T) {
	var input time.Time
	cases := []struct {
		value, result interface{}
		pass          bool
	}{
		{input, input, true},
	}
	for _, c := range cases {
		result, err := etl.TransformAutoTime(c.value)
		if c.pass {
			assert.Equal(t, c.result, result)
		} else {
			assert.Error(t, err)
		}
	}
}

// TestConvertFloat32 : test convert float32
func TestConvertFloat32(t *testing.T) {
	var input float32
	cases := []struct {
		value, result interface{}
	}{
		{input, input},
		{nil, input},
	}
	for _, c := range cases {
		result, err := etl.TransformFloat32(c.value)
		assert.NoError(t, err)
		assert.Equal(t, c.result, result)
	}
}

// TestConvertNilFloat32 : test convert float32 allow nil
func TestConvertNilFloat32(t *testing.T) {
	var input float32
	cases := []struct {
		value, result interface{}
	}{
		{input, input},
		{nil, nil},
	}
	for _, c := range cases {
		result, err := etl.TransformNilFloat32(c.value)
		assert.NoError(t, err)
		assert.Equal(t, c.result, result)
	}
}

// TestConvertNotNilFloat32 : test convert float32 not allow nil
func TestConvertNotNilFloat32(t *testing.T) {
	var input float32
	cases := []struct {
		value, result interface{}
		err           error
	}{
		{input, input, nil},
		{nil, nil, etl.ErrTypeNotSupported},
	}
	for _, c := range cases {
		result, err := etl.TransformNotNilFloat32(c.value)
		assert.Equal(t, c.result, result)
		assert.Equal(t, c.err, err)
	}
}

// TestConvertAutoFloat32 : test convert float32
func TestConvertAutoFloat32(t *testing.T) {
	var input float32
	cases := []struct {
		value, result interface{}
		pass          bool
	}{
		{input, input, true},
	}
	for _, c := range cases {
		result, err := etl.TransformAutoFloat32(c.value)
		if c.pass {
			assert.Equal(t, c.result, result)
		} else {
			assert.Error(t, err)
		}
	}
}

// TestConvertFloat64 : test convert float64
func TestConvertFloat64(t *testing.T) {
	var input float64
	cases := []struct {
		value, result interface{}
	}{
		{input, input},
		{nil, input},
	}
	for _, c := range cases {
		result, err := etl.TransformFloat64(c.value)
		assert.NoError(t, err)
		assert.Equal(t, c.result, result)
	}
}

// TestConvertNilFloat64 : test convert float64 allow nil
func TestConvertNilFloat64(t *testing.T) {
	var input float64
	cases := []struct {
		value, result interface{}
	}{
		{input, input},
		{nil, nil},
	}
	for _, c := range cases {
		result, err := etl.TransformNilFloat64(c.value)
		assert.NoError(t, err)
		assert.Equal(t, c.result, result)
	}
}

// TestConvertNotNilFloat64 : test convert float64 not allow nil
func TestConvertNotNilFloat64(t *testing.T) {
	var input float64
	cases := []struct {
		value, result interface{}
		err           error
	}{
		{input, input, nil},
		{nil, nil, etl.ErrTypeNotSupported},
	}
	for _, c := range cases {
		result, err := etl.TransformNotNilFloat64(c.value)
		assert.Equal(t, c.result, result)
		assert.Equal(t, c.err, err)
	}
}

// TestConvertAutoFloat64 : test convert float64
func TestConvertAutoFloat64(t *testing.T) {
	var input float64
	cases := []struct {
		value, result interface{}
		pass          bool
	}{
		{input, input, true},
	}
	for _, c := range cases {
		result, err := etl.TransformAutoFloat64(c.value)
		if c.pass {
			assert.Equal(t, c.result, result)
		} else {
			assert.Error(t, err)
		}
	}
}

// TestConvertInt : test convert int
func TestConvertInt(t *testing.T) {
	var input int
	cases := []struct {
		value, result interface{}
	}{
		{input, input},
		{nil, input},
	}
	for _, c := range cases {
		result, err := etl.TransformInt(c.value)
		assert.NoError(t, err)
		assert.Equal(t, c.result, result)
	}
}

// TestConvertNilInt : test convert int allow nil
func TestConvertNilInt(t *testing.T) {
	var input int
	cases := []struct {
		value, result interface{}
	}{
		{input, input},
		{nil, nil},
	}
	for _, c := range cases {
		result, err := etl.TransformNilInt(c.value)
		assert.NoError(t, err)
		assert.Equal(t, c.result, result)
	}
}

// TestConvertNotNilInt : test convert int not allow nil
func TestConvertNotNilInt(t *testing.T) {
	var input int
	cases := []struct {
		value, result interface{}
		err           error
	}{
		{input, input, nil},
		{nil, nil, etl.ErrTypeNotSupported},
	}
	for _, c := range cases {
		result, err := etl.TransformNotNilInt(c.value)
		assert.Equal(t, c.result, result)
		assert.Equal(t, c.err, err)
	}
}

// TestConvertAutoInt : test convert int
func TestConvertAutoInt(t *testing.T) {
	var input int
	cases := []struct {
		value, result interface{}
		pass          bool
	}{
		{input, input, true},
	}
	for _, c := range cases {
		result, err := etl.TransformAutoInt(c.value)
		if c.pass {
			assert.Equal(t, c.result, result)
		} else {
			assert.Error(t, err)
		}
	}
}

// TestConvertInt8 : test convert int8
func TestConvertInt8(t *testing.T) {
	var input int8
	cases := []struct {
		value, result interface{}
	}{
		{input, input},
		{nil, input},
	}
	for _, c := range cases {
		result, err := etl.TransformInt8(c.value)
		assert.NoError(t, err)
		assert.Equal(t, c.result, result)
	}
}

// TestConvertNilInt8 : test convert int8 allow nil
func TestConvertNilInt8(t *testing.T) {
	var input int8
	cases := []struct {
		value, result interface{}
	}{
		{input, input},
		{nil, nil},
	}
	for _, c := range cases {
		result, err := etl.TransformNilInt8(c.value)
		assert.NoError(t, err)
		assert.Equal(t, c.result, result)
	}
}

// TestConvertNotNilInt8 : test convert int8 not allow nil
func TestConvertNotNilInt8(t *testing.T) {
	var input int8
	cases := []struct {
		value, result interface{}
		err           error
	}{
		{input, input, nil},
		{nil, nil, etl.ErrTypeNotSupported},
	}
	for _, c := range cases {
		result, err := etl.TransformNotNilInt8(c.value)
		assert.Equal(t, c.result, result)
		assert.Equal(t, c.err, err)
	}
}

// TestConvertAutoInt8 : test convert int8
func TestConvertAutoInt8(t *testing.T) {
	var input int8
	cases := []struct {
		value, result interface{}
		pass          bool
	}{
		{input, input, true},
	}
	for _, c := range cases {
		result, err := etl.TransformAutoInt8(c.value)
		if c.pass {
			assert.Equal(t, c.result, result)
		} else {
			assert.Error(t, err)
		}
	}
}

// TestConvertInt16 : test convert int16
func TestConvertInt16(t *testing.T) {
	var input int16
	cases := []struct {
		value, result interface{}
	}{
		{input, input},
		{nil, input},
	}
	for _, c := range cases {
		result, err := etl.TransformInt16(c.value)
		assert.NoError(t, err)
		assert.Equal(t, c.result, result)
	}
}

// TestConvertNilInt16 : test convert int16 allow nil
func TestConvertNilInt16(t *testing.T) {
	var input int16
	cases := []struct {
		value, result interface{}
	}{
		{input, input},
		{nil, nil},
	}
	for _, c := range cases {
		result, err := etl.TransformNilInt16(c.value)
		assert.NoError(t, err)
		assert.Equal(t, c.result, result)
	}
}

// TestConvertNotNilInt16 : test convert int16 not allow nil
func TestConvertNotNilInt16(t *testing.T) {
	var input int16
	cases := []struct {
		value, result interface{}
		err           error
	}{
		{input, input, nil},
		{nil, nil, etl.ErrTypeNotSupported},
	}
	for _, c := range cases {
		result, err := etl.TransformNotNilInt16(c.value)
		assert.Equal(t, c.result, result)
		assert.Equal(t, c.err, err)
	}
}

// TestConvertAutoInt16 : test convert int16
func TestConvertAutoInt16(t *testing.T) {
	var input int16
	cases := []struct {
		value, result interface{}
		pass          bool
	}{
		{input, input, true},
	}
	for _, c := range cases {
		result, err := etl.TransformAutoInt16(c.value)
		if c.pass {
			assert.Equal(t, c.result, result)
		} else {
			assert.Error(t, err)
		}
	}
}

// TestConvertInt32 : test convert int32
func TestConvertInt32(t *testing.T) {
	var input int32
	cases := []struct {
		value, result interface{}
	}{
		{input, input},
		{nil, input},
	}
	for _, c := range cases {
		result, err := etl.TransformInt32(c.value)
		assert.NoError(t, err)
		assert.Equal(t, c.result, result)
	}
}

// TestConvertNilInt32 : test convert int32 allow nil
func TestConvertNilInt32(t *testing.T) {
	var input int32
	cases := []struct {
		value, result interface{}
	}{
		{input, input},
		{nil, nil},
	}
	for _, c := range cases {
		result, err := etl.TransformNilInt32(c.value)
		assert.NoError(t, err)
		assert.Equal(t, c.result, result)
	}
}

// TestConvertNotNilInt32 : test convert int32 not allow nil
func TestConvertNotNilInt32(t *testing.T) {
	var input int32
	cases := []struct {
		value, result interface{}
		err           error
	}{
		{input, input, nil},
		{nil, nil, etl.ErrTypeNotSupported},
	}
	for _, c := range cases {
		result, err := etl.TransformNotNilInt32(c.value)
		assert.Equal(t, c.result, result)
		assert.Equal(t, c.err, err)
	}
}

// TestConvertAutoInt32 : test convert int32
func TestConvertAutoInt32(t *testing.T) {
	var input int32
	cases := []struct {
		value, result interface{}
		pass          bool
	}{
		{input, input, true},
	}
	for _, c := range cases {
		result, err := etl.TransformAutoInt32(c.value)
		if c.pass {
			assert.Equal(t, c.result, result)
		} else {
			assert.Error(t, err)
		}
	}
}

// TestConvertInt64 : test convert int64
func TestConvertInt64(t *testing.T) {
	var input int64
	cases := []struct {
		value, result interface{}
	}{
		{input, input},
		{nil, input},
	}
	for _, c := range cases {
		result, err := etl.TransformInt64(c.value)
		assert.NoError(t, err)
		assert.Equal(t, c.result, result)
	}
}

// TestConvertNilInt64 : test convert int64 allow nil
func TestConvertNilInt64(t *testing.T) {
	var input int64
	cases := []struct {
		value, result interface{}
	}{
		{input, input},
		{nil, nil},
	}
	for _, c := range cases {
		result, err := etl.TransformNilInt64(c.value)
		assert.NoError(t, err)
		assert.Equal(t, c.result, result)
	}
}

// TestConvertNotNilInt64 : test convert int64 not allow nil
func TestConvertNotNilInt64(t *testing.T) {
	var input int64
	cases := []struct {
		value, result interface{}
		err           error
	}{
		{input, input, nil},
		{nil, nil, etl.ErrTypeNotSupported},
	}
	for _, c := range cases {
		result, err := etl.TransformNotNilInt64(c.value)
		assert.Equal(t, c.result, result)
		assert.Equal(t, c.err, err)
	}
}

// TestConvertAutoInt64 : test convert int64
func TestConvertAutoInt64(t *testing.T) {
	var input int64
	cases := []struct {
		value, result interface{}
		pass          bool
	}{
		{input, input, true},
	}
	for _, c := range cases {
		result, err := etl.TransformAutoInt64(c.value)
		if c.pass {
			assert.Equal(t, c.result, result)
		} else {
			assert.Error(t, err)
		}
	}
}

// TestConvertUint : test convert uint
func TestConvertUint(t *testing.T) {
	var input uint
	cases := []struct {
		value, result interface{}
	}{
		{input, input},
		{nil, input},
	}
	for _, c := range cases {
		result, err := etl.TransformUint(c.value)
		assert.NoError(t, err)
		assert.Equal(t, c.result, result)
	}
}

// TestConvertNilUint : test convert uint allow nil
func TestConvertNilUint(t *testing.T) {
	var input uint
	cases := []struct {
		value, result interface{}
	}{
		{input, input},
		{nil, nil},
	}
	for _, c := range cases {
		result, err := etl.TransformNilUint(c.value)
		assert.NoError(t, err)
		assert.Equal(t, c.result, result)
	}
}

// TestConvertNotNilUint : test convert uint not allow nil
func TestConvertNotNilUint(t *testing.T) {
	var input uint
	cases := []struct {
		value, result interface{}
		err           error
	}{
		{input, input, nil},
		{nil, nil, etl.ErrTypeNotSupported},
	}
	for _, c := range cases {
		result, err := etl.TransformNotNilUint(c.value)
		assert.Equal(t, c.result, result)
		assert.Equal(t, c.err, err)
	}
}

// TestConvertAutoUint : test convert uint
func TestConvertAutoUint(t *testing.T) {
	var input uint
	cases := []struct {
		value, result interface{}
		pass          bool
	}{
		{input, input, true},
	}
	for _, c := range cases {
		result, err := etl.TransformAutoUint(c.value)
		if c.pass {
			assert.Equal(t, c.result, result)
		} else {
			assert.Error(t, err)
		}
	}
}

// TestConvertUint8 : test convert uint8
func TestConvertUint8(t *testing.T) {
	var input uint8
	cases := []struct {
		value, result interface{}
	}{
		{input, input},
		{nil, input},
	}
	for _, c := range cases {
		result, err := etl.TransformUint8(c.value)
		assert.NoError(t, err)
		assert.Equal(t, c.result, result)
	}
}

// TestConvertNilUint8 : test convert uint8 allow nil
func TestConvertNilUint8(t *testing.T) {
	var input uint8
	cases := []struct {
		value, result interface{}
	}{
		{input, input},
		{nil, nil},
	}
	for _, c := range cases {
		result, err := etl.TransformNilUint8(c.value)
		assert.NoError(t, err)
		assert.Equal(t, c.result, result)
	}
}

// TestConvertNotNilUint8 : test convert uint8 not allow nil
func TestConvertNotNilUint8(t *testing.T) {
	var input uint8
	cases := []struct {
		value, result interface{}
		err           error
	}{
		{input, input, nil},
		{nil, nil, etl.ErrTypeNotSupported},
	}
	for _, c := range cases {
		result, err := etl.TransformNotNilUint8(c.value)
		assert.Equal(t, c.result, result)
		assert.Equal(t, c.err, err)
	}
}

// TestConvertAutoUint8 : test convert uint8
func TestConvertAutoUint8(t *testing.T) {
	var input uint8
	cases := []struct {
		value, result interface{}
		pass          bool
	}{
		{input, input, true},
	}
	for _, c := range cases {
		result, err := etl.TransformAutoUint8(c.value)
		if c.pass {
			assert.Equal(t, c.result, result)
		} else {
			assert.Error(t, err)
		}
	}
}

// TestConvertUint16 : test convert uint16
func TestConvertUint16(t *testing.T) {
	var input uint16
	cases := []struct {
		value, result interface{}
	}{
		{input, input},
		{nil, input},
	}
	for _, c := range cases {
		result, err := etl.TransformUint16(c.value)
		assert.NoError(t, err)
		assert.Equal(t, c.result, result)
	}
}

// TestConvertNilUint16 : test convert uint16 allow nil
func TestConvertNilUint16(t *testing.T) {
	var input uint16
	cases := []struct {
		value, result interface{}
	}{
		{input, input},
		{nil, nil},
	}
	for _, c := range cases {
		result, err := etl.TransformNilUint16(c.value)
		assert.NoError(t, err)
		assert.Equal(t, c.result, result)
	}
}

// TestConvertNotNilUint16 : test convert uint16 not allow nil
func TestConvertNotNilUint16(t *testing.T) {
	var input uint16
	cases := []struct {
		value, result interface{}
		err           error
	}{
		{input, input, nil},
		{nil, nil, etl.ErrTypeNotSupported},
	}
	for _, c := range cases {
		result, err := etl.TransformNotNilUint16(c.value)
		assert.Equal(t, c.result, result)
		assert.Equal(t, c.err, err)
	}
}

// TestConvertAutoUint16 : test convert uint16
func TestConvertAutoUint16(t *testing.T) {
	var input uint16
	cases := []struct {
		value, result interface{}
		pass          bool
	}{
		{input, input, true},
	}
	for _, c := range cases {
		result, err := etl.TransformAutoUint16(c.value)
		if c.pass {
			assert.Equal(t, c.result, result)
		} else {
			assert.Error(t, err)
		}
	}
}

// TestConvertUint32 : test convert uint32
func TestConvertUint32(t *testing.T) {
	var input uint32
	cases := []struct {
		value, result interface{}
	}{
		{input, input},
		{nil, input},
	}
	for _, c := range cases {
		result, err := etl.TransformUint32(c.value)
		assert.NoError(t, err)
		assert.Equal(t, c.result, result)
	}
}

// TestConvertNilUint32 : test convert uint32 allow nil
func TestConvertNilUint32(t *testing.T) {
	var input uint32
	cases := []struct {
		value, result interface{}
	}{
		{input, input},
		{nil, nil},
	}
	for _, c := range cases {
		result, err := etl.TransformNilUint32(c.value)
		assert.NoError(t, err)
		assert.Equal(t, c.result, result)
	}
}

// TestConvertNotNilUint32 : test convert uint32 not allow nil
func TestConvertNotNilUint32(t *testing.T) {
	var input uint32
	cases := []struct {
		value, result interface{}
		err           error
	}{
		{input, input, nil},
		{nil, nil, etl.ErrTypeNotSupported},
	}
	for _, c := range cases {
		result, err := etl.TransformNotNilUint32(c.value)
		assert.Equal(t, c.result, result)
		assert.Equal(t, c.err, err)
	}
}

// TestConvertAutoUint32 : test convert uint32
func TestConvertAutoUint32(t *testing.T) {
	var input uint32
	cases := []struct {
		value, result interface{}
		pass          bool
	}{
		{input, input, true},
	}
	for _, c := range cases {
		result, err := etl.TransformAutoUint32(c.value)
		if c.pass {
			assert.Equal(t, c.result, result)
		} else {
			assert.Error(t, err)
		}
	}
}

// TestConvertUint64 : test convert uint64
func TestConvertUint64(t *testing.T) {
	var input uint64
	cases := []struct {
		value, result interface{}
	}{
		{input, input},
		{nil, input},
	}
	for _, c := range cases {
		result, err := etl.TransformUint64(c.value)
		assert.NoError(t, err)
		assert.Equal(t, c.result, result)
	}
}

// TestConvertNilUint64 : test convert uint64 allow nil
func TestConvertNilUint64(t *testing.T) {
	var input uint64
	cases := []struct {
		value, result interface{}
	}{
		{input, input},
		{nil, nil},
	}
	for _, c := range cases {
		result, err := etl.TransformNilUint64(c.value)
		assert.NoError(t, err)
		assert.Equal(t, c.result, result)
	}
}

// TestConvertNotNilUint64 : test convert uint64 not allow nil
func TestConvertNotNilUint64(t *testing.T) {
	var input uint64
	cases := []struct {
		value, result interface{}
		err           error
	}{
		{input, input, nil},
		{nil, nil, etl.ErrTypeNotSupported},
	}
	for _, c := range cases {
		result, err := etl.TransformNotNilUint64(c.value)
		assert.Equal(t, c.result, result)
		assert.Equal(t, c.err, err)
	}
}

// TestConvertAutoUint64 : test convert uint64
func TestConvertAutoUint64(t *testing.T) {
	var input uint64
	cases := []struct {
		value, result interface{}
		pass          bool
	}{
		{input, input, true},
	}
	for _, c := range cases {
		result, err := etl.TransformAutoUint64(c.value)
		if c.pass {
			assert.Equal(t, c.result, result)
		} else {
			assert.Error(t, err)
		}
	}
}
